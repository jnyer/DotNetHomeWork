<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="SpringBoot&#x2B;Spring Security&#x2B;OAuth2.0 实现初版第三方登录效果" />
    <meta property="og:description" content="SpringBoot&#x2B;Spring Security&#x2B;OAuth2.0 实现初版第三方登录效果" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Spring Security OAuth2.0认证授权一：框架搭建和认证测试 - 狂盗一枝梅 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    <link id="MainCss" rel="stylesheet" href="/skins/bluesky/bundle-bluesky.min.css?v=crS-BJKdvIW2vVfJGJMix4EoW6XR-Z12_psc8V6YTNc" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/kuangdaoyizhimei/custom.css?v=tRPNC0STV2420eKosFf5BNi2g6U=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/bluesky/bundle-bluesky-mobile.min.css?v=R6fv62IpzGSvTM7pHsnRgkrk1El3gMSYm75Iwe80srs" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/kuangdaoyizhimei/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/kuangdaoyizhimei/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/kuangdaoyizhimei/wlwmanifest.xml" />
    <script>
        var currentBlogId = 147792;
        var currentBlogApp = 'kuangdaoyizhimei';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'BlueSky';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-01-08 10:55';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=yJQaJ16S00coMfzvh-NgF2zm2J87f5VfNamFdsnKHrc"></script>
    
    
    
</head>
<body class="no-navbar">
    <a name="top"></a>
    <div id="top_nav" class="navbar forpc navbar-custom">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        <!-- ............自定义首部代码开始............ -->
<!-- 自定义进度条 -->
<div id="myProgressBar" style="display: none;"></div>

<!-- 自定义导航条 -->
<div id="mynavbar" style="margin-top: 0px;">
    <div style="position:relative;width:65pc;height:70px;margin:0 auto;">
    	<a style="width: auto;height: 22px;margin-left: 25px;" class="c-c"  href="https://www.cnblogs.com/kuangdaoyizhimei">
<img id="nv-icon" style="width: auto;height: 38px;outline: 0;margin-top: 12px;">

    	</a>
    	<div id="mynavbar_menu">
	    	<a href="https://www.cnblogs.com/summertime-wu" class="c-c">首页</a>
	    	<a href="https://msg.cnblogs.com/send/summertime-wu" class="c-c">联系</a>
	    	<a id="myGayhubUrl" href="https://github.com/Summertime-Wu" class="c-c">Github</a>
	    	<a id="friendLink" href="#">友情链接</a>
	    	<a href="https://www.cnblogs.com/">博客园</a>
            <a href="https://i.cnblogs.com/posts">管理</a>
	    	<a id="aboutMe" href="#">关于</a>
	    </div>
    </div>
</div>

<!-- 自定义头部锚点 -->
<a name="mtop"></a>

<!-- 自定义头部 -->
<div id="myheader">
	<!-- 背景图片 -->
    <div id="myheader_bg"></div>
    <!-- 遮罩层 -->
    <div id="myheader_cover" title="点我点我">
        <!-- 博客标题 -->
        <div id="mypost_title">
            <div id="mypost_title_h" style="font-weight: 500;font-size: 21px;"></div>
            <div id="mypost_title_f"></div>
            <div id="mypost_title_e">
                <a href="https://www.cnblogs.com/" class="c-c" style="">暂未分类</a>
            </div> 
        </div>  
    </div>
</div>
<!-- ............自定义首部代码结束............ -->
    </div>
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/kuangdaoyizhimei/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/kuangdaoyizhimei/">狂盗一枝梅</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/kuangdaoyizhimei/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%8B%82%E7%9B%97%E4%B8%80%E6%9E%9D%E6%A2%85">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/kuangdaoyizhimei/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kuangdaoyizhimei/p/14250374.html">
    <span>Spring Security OAuth2.0认证授权一：框架搭建和认证测试</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        SpringBoot+Spring Security+OAuth2.0 实现初版第三方登录效果
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一、oauth20介绍">一、OAuth2.0介绍</h2>
<p>OAuth（开放授权）是一个开放标准，<strong>允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不 需要将用户名和密码提供给第三方应用或分享他们数据的所有内容</strong>。</p>
<h3 id="1stackoverflow和github">1.stackoverflow和github</h3>
<p>听起来挺拗口，不如举个例子说明下，就以stackoverflow登录为例：我们登录stackoverflow，网站上会提示几种登录方式，如下所示</p>
<p><img src="https://img2020.cnblogs.com/blog/516671/202101/516671-20210108105027833-1976825.jpeg;%20charset=UTF-8" alt="微信图片_20210108011337.jpg" loading="lazy"></p>
<p>其中有一种github登录的方式，点一下进入以下页面</p>
<p><img src="https://img2020.cnblogs.com/news/516671/202101/516671-20210108105029277-1150252112.jpeg;%20charset=UTF-8" alt="微信图片_20210108011323.jpg" loading="lazy"></p>
<p>这个页面实际上是github授权登陆stackoverflow的页面，只要点击授权按钮，就可以使用github上注册的相关信息注册stackoverflow了，仔细看下这个授权页面，这个授权页面上有几个值得注意的点：</p>
<ol>
<li>图片中介绍了三方角色信息：当前操作人，github以及stackoverflow</li>
<li>stackoverflow想通过github获取你的个人信息，哪些个人信息呢？Email addresses (read-only),邮箱地址，而且是只读，也就是说就算你授权了stackoverflow，它也修改不了你github上的个人信息。</li>
<li>授权按钮，以及下面的一行小字<code>Authorizing will redirect to **https://stackauth.com**</code>，也就是说如果你点击了授权按钮，页面将重定向到stackauth.com页面。点击授权按钮之后就仿佛使用github的账号登录上了stackoverflow一样。</li>
</ol>
<p>这里操作人、github、stackoverflow分别扮演了什么角色，stackoverflow是如何从github获取到个人信息的呢？这里实际上使用的是auth2.0协议进行的认证和授权。</p>
<h3 id="2auth20协议">2.auth2.0协议</h3>
<p>我们看OAuth2.0认证流程：引自OAauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749" target="_blank">https://tools.ietf.org/html/rfc6749</a></p>
<pre><code class="language-txt">     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&gt;| Authorization |
     | Client |                               |     Server    |
     |        |&lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&gt;|    Resource   |
     |        |                               |     Server    |
     |        |&lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure 1: Abstract Protocol Flow

   The abstract OAuth 2.0 flow illustrated in Figure 1 describes the
   interaction between the four roles and includes the following steps:

   (A)  The client requests authorization from the resource owner.  The
        authorization request can be made directly to the resource owner
        (as shown), or preferably indirectly via the authorization
        server as an intermediary.

   (B)  The client receives an authorization grant, which is a
        credential representing the resource owner's authorization,
        expressed using one of four grant types defined in this
        specification or using an extension grant type.  The
        authorization grant type depends on the method used by the
        client to request authorization and the types supported by the
        authorization server.

   (C)  The client requests an access token by authenticating with the
        authorization server and presenting the authorization grant.

   (D)  The authorization server authenticates the client and validates
        the authorization grant, and if valid, issues an access token.

   (E)  The client requests the protected resource from the resource
        server and authenticates by presenting the access token.

   (F)  The resource server validates the access token, and if valid,
        serves the request.

Hardt                        Standards Track                    [Page 7]
</code></pre>
<hr>
<p>OAauth2.0包括以下角色：</p>
<p><strong>1、客户端</strong></p>
<p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏<br>
览器端）、微信客户端等，在上面的例子中，stackoverflow扮演的正是这个角色。</p>
<p><strong>2、资源拥有者</strong></p>
<p>通常为用户，也可以是应用程序，即该资源的拥有者。在上面的例子中，资源拥有者指的是在github上已经注册的用户。</p>
<p><strong>3、授权服务器（也称认证服务器）</strong></p>
<p>用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌<br>
（access_token），作为客户端访问资源服务器的凭据。本例为github。</p>
<p><strong>4、资源服务器</strong></p>
<p>存储资源的服务器，本例子为github存储的用户信息。</p>
<p>如此，上面使用github登陆stackoverflow的流程大体上如下图所示：</p>
<p><img src="https://img2020.cnblogs.com/blog/516671/202101/516671-20210108105029674-669659689.png;%20charset=UTF-8" alt="auth流程图.png" loading="lazy"></p>
<p>下面将演示如何使用spring boot搭建OAuth2.0认证中心以实现类似于stackoverflow使用github账号登陆的效果。</p>
<h2 id="二、使用springboot搭建oauth20认证中心">二、使用springboot搭建OAuth2.0认证中心</h2>
<p>项目目录层次如下：</p>
<pre><code class="language-tree">├── docs
│&nbsp;&nbsp; └── sql
│&nbsp;&nbsp;     └── init.sql
├── pom.xml
└── src
    ├── main
    │&nbsp;&nbsp; ├── java
    │&nbsp;&nbsp; │&nbsp;&nbsp; └── com
    │&nbsp;&nbsp; │&nbsp;&nbsp;     └── kdyzm
    │&nbsp;&nbsp; │&nbsp;&nbsp;         └── spring
    │&nbsp;&nbsp; │&nbsp;&nbsp;             └── security
    │&nbsp;&nbsp; │&nbsp;&nbsp;                 └── auth
    │&nbsp;&nbsp; │&nbsp;&nbsp;                     └── center
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── AuthCenterApplication.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── config
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; ├── AuthorizationServer.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; ├── MybatisPlusConfig.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; ├── TokenConfig.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; └── WebSecurityConfig.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── controller
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; └── GrantController.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── entity
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; └── TUser.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── handler
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; └── MyAuthenticationFailureHandler.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         ├── mapper
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         │&nbsp;&nbsp; └── UserMapper.java
    │&nbsp;&nbsp; │&nbsp;&nbsp;                         └── service
    │&nbsp;&nbsp; │&nbsp;&nbsp;                             └── MyUserDetailsServiceImpl.java
    │&nbsp;&nbsp; └── resources
    │&nbsp;&nbsp;     ├── application.yml
    │&nbsp;&nbsp;     ├── static
    │&nbsp;&nbsp;     │&nbsp;&nbsp; ├── css
    │&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; ├── bootstrap.min.css
    │&nbsp;&nbsp;     │&nbsp;&nbsp; │&nbsp;&nbsp; └── signin.css
    │&nbsp;&nbsp;     │&nbsp;&nbsp; └── login.html
    │&nbsp;&nbsp;     └── templates
    │&nbsp;&nbsp;         └── grant.html
</code></pre>
<p>项目源代码地址：<a href="https://gitee.com/kdyzm/spring-security-oauth-study/tree/v2.0.0" target="_blank">https://gitee.com/kdyzm/spring-security-oauth-study/tree/v2.0.0</a> （认准v2.0.0标签）</p>
<p>接下来捡着重点说下搭建过程</p>
<h3 id="1引入最核心的三个maven依赖">1.引入最核心的三个maven依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>像是mybatis、mybatis  plus、fastjson、lombok、thymeleaf等依赖都是辅助依赖，不赘述</p>
<h3 id="2编写启动类">2.编写启动类</h3>
<pre><code class="language-java">@SpringBootApplication
public class AuthCenterApplication {

    public static void main(String[] args) {
        SpringApplication.run(AuthCenterApplication.class, args);
    }
}
</code></pre>
<h3 id="3配置文件">3.配置文件</h3>
<pre><code class="language-properties">server:
  port: 30000
spring:
  application:
    name: auth-center
  datasource:
    url: jdbc:mysql://${db}/security?useSSL=false&amp;userUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC
    username: root
    password: ${db_password}
    driver-class-name: com.mysql.jdbc.Driver
  thymeleaf:
    prefix: classpath:/templates/
    suffix: .html
    cache: false
</code></pre>
<p>配置完以上三项，就可以将项目正常启动起来了，但是是一个一片空白的项目。接下来配置核心代码实现，需要说明的一点是，<a href="https://gitee.com/kdyzm/spring-security-oauth-study/tree/v1.0.0" target="_blank">https://gitee.com/kdyzm/spring-security-oauth-study/tree/v1.0.0</a> 该标签下的代码未配置自定义登录页面和授权页面，是实现OAuth2.0认证中心最简单的代码。</p>
<h3 id="4enableauthorizationserver">4.EnableAuthorizationServer</h3>
<p>可以用 @EnableAuthorizationServer 注解并继承AuthorizationServerConfigurerAdapter来配置OAuth2.0 授权服务器。</p>
<p>在config包下创建AuthorizationServer：</p>
<pre><code class="language-java">@Configuration
@EnableAuthorizationServer
public class AuthorizationServer extends AuthorizationServerConfigurerAdapter{
    ......
}
</code></pre>
<p>AuthorizationServerConfigurerAdapter要求重写以下三个方法并配置方法中的几个类，这几个类是由Spring创建的独立的配置对象，它们会被Spring传入AuthorizationServerConfigurer中进行配置。</p>
<pre><code class="language-java">public&nbsp;void&nbsp;configure(AuthorizationServerSecurityConfigurer&nbsp;security)&nbsp;throws&nbsp;Exception&nbsp;{}
public&nbsp;void&nbsp;configure(ClientDetailsServiceConfigurer&nbsp;clients)&nbsp;throws&nbsp;Exception&nbsp;{}
public&nbsp;void&nbsp;configure(AuthorizationServerEndpointsConfigurer&nbsp;endpoints)&nbsp;throws&nbsp;Exception&nbsp;{}
</code></pre>
<ul>
<li>ClientDetailsServiceConfigurer ：用来配置客户端详情服务（ClientDetailsService），客户端详情信息在这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。</li>
<li>AuthorizationServerEndpointsConfigurer ：用来配置令牌（token）的访问端点和令牌服务(tokenservices)。</li>
<li>AuthorizationServerSecurityConfigurer ：用来配置令牌端点的安全约束.</li>
</ul>
<h3 id="5配置客户端详细信息">5.配置客户端详细信息</h3>
<p>ClientDetailsServiceConfigurer 能够使用内存或者JDBC来实现客户端详情服务（ClientDetailsService），ClientDetailsService负责查找ClientDetails，而ClientDetails有几个重要的属性如下列表：</p>
<ul>
<li>clientId ：（必须的）用来标识客户的Id。</li>
<li>secret ：（需要值得信任的客户端）客户端安全码，如果有的话。</li>
<li>scope ：用来限制客户端的访问范围，如果为空（默认）的话，那么客户端拥有全部的访问范围。</li>
<li>authorizedGrantTypes ：此客户端可以使用的授权类型，默认为空。</li>
<li>authorities ：此客户端可以使用的权限（基于Spring Security authorities）。</li>
</ul>
<p>客户端详情（Client Details）能够在应用程序运行的时候进行更新，可以通过访问底层的存储服务（例如将客户端详情存储在一个关系数据库的表中，就可以使用 JdbcClientDetailsService）或者通过自己实现ClientRegistrationService接口（同时你也可以实现 ClientDetailsService 接口）来进行管理。</p>
<p>我们暂时使用内存方式存储客户端详情信息，配置如下:</p>
<pre><code class="language-java">    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory() 				//使用in‐memory存储
                .withClient("c1")
                .secret(new BCryptPasswordEncoder().encode("secret"))//$2a$10$0uhIO.ADUFv7OQ/kuwsC1.o3JYvnevt5y3qX/ji0AUXs4KYGio3q6
                .resourceIds("r1")
                .authorizedGrantTypes("authorization_code", "password", "client_credentials", "implicit", "refresh_token")//该client允许的授权类型
                .scopes("all")			//授权范围
                .autoApprove(false)
                .redirectUris("https://www.baidu.com");
    }
</code></pre>
<h3 id="6管理令牌">6.管理令牌</h3>
<p>AuthorizationServerTokenServices 接口定义了一些操作使得你可以对令牌进行一些必要的管理，令牌可以被用来加载身份信息，里面包含了这个令牌的相关权限。</p>
<p>自己可以创建 AuthorizationServerTokenServices 这个接口的实现，则需要继承 DefaultTokenServices 这个类，里面包含了一些有用实现，你可以使用它来修改令牌的格式和令牌的存储。默认的，当它尝试创建一个令牌的时候，是使用随机值来进行填充的，除了持久化令牌是委托一个 TokenStore 接口来实现以外，这个类几乎帮你做了所有的事情。并且 TokenStore 这个接口有一个默认的实现，它就是 InMemoryTokenStore ，如其命名，所有的令牌是被保存在了内存中。除了使用这个类以外，你还可以使用一些其他的预定义实现，下面有几个版本，它们都实现了TokenStore接口：</p>
<ul>
<li>InMemoryTokenStore ：这个版本的实现是被默认采用的，它可以完美的工作在单服务器上（即访问并发量压力不大的情况下，并且它在失败的时候不会进行备份），大多数的项目都可以使用这个版本的实现来进行尝试，你可以在开发的时候使用它来进行管理，因为不会被保存到磁盘中，所以更易于调试。</li>
<li>JdbcTokenStore ：这是一个基于JDBC的实现版本，令牌会被保存进关系型数据库。使用这个版本的实现时，你可以在不同的服务器之间共享令牌信息，使用这个版本的时候请注意把"spring-jdbc"这个依赖加入到你的classpath当中。</li>
<li>JwtTokenStore ：这个版本的全称是 JSON Web Token（JWT），它可以把令牌相关的数据进行编码（因此对于后端服务来说，它不需要进行存储，这将是一个重大优势），但是它有一个缺点，那就是撤销一个已经授权令牌将会非常困难，所以它通常用来处理一个生命周期较短的令牌以及撤销刷新令牌（refresh_token）。另外一个缺点就是这个令牌占用的空间会比较大，如果你加入了比较多用户凭证信息。JwtTokenStore 不会保存任何数据，但是它在转换令牌值以及授权信息方面与 DefaultTokenServices 所扮演的角色是一样的。</li>
</ul>
<p><strong>6.1 定义TokenConfig</strong></p>
<p>在config包下定义TokenConfig，我们暂时先使用InMemoryTokenStore，生成一个普通的令牌。</p>
<pre><code>@Configuration 
public&nbsp;class&nbsp;TokenConfig&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;@Bean
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;TokenStore&nbsp;tokenStore()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;InMemoryTokenStore();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p><strong>6.2 定义ClientDetailsService</strong></p>
<p>由于配置了5，所以这里会spring会帮我们生成一个基于内存的 ClientDetailsService</p>
<p><strong>6.3 定义AuthorizationServerTokenServices</strong></p>
<p>在AuthorizationServer中定义AuthorizationServerTokenServices</p>
<pre><code class="language-java">@Autowired
private TokenStore tokenStore;

@Autowired
private ClientDetailsService clientDetailsService;

@Bean
public AuthorizationServerTokenServices tokenServices(){
    DefaultTokenServices services = new DefaultTokenServices();
    services.setClientDetailsService(clientDetailsService);
    services.setSupportRefreshToken(true);
    services.setTokenStore(tokenStore);
    services.setAccessTokenValiditySeconds(7200);
    services.setRefreshTokenValiditySeconds(259200);
    return services;
}
</code></pre>
<h3 id="7令牌访问端点配置">7.令牌访问端点配置</h3>
<p>AuthorizationServerEndpointsConfigurer 这个对象的实例可以完成令牌服务以及令牌endpoint配置。</p>
<p><strong>7.1 AuthorizationServerEndpointsConfigurer 授权类型</strong></p>
<p>AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型（Grant Types）:</p>
<ul>
<li>authenticationManager ：认证管理器，<strong>当你选择了资源所有者密码（password）授权类型的时候，请设置这个属性注入一个 AuthenticationManager 对象</strong>。</li>
<li>userDetailsService ：<strong>如果你设置了这个属性的话，那说明你有一个自己的 UserDetailsService 接口的实现</strong>，或者你可以把这个东西设置到全局域上面去（例如 GlobalAuthenticationManagerConfigurer 这个配置对象），当你设置了这个之后，那么 "refresh_token" 即刷新令牌授权类型模式的流程中就会包含一个检查，用来确保这个账号是否仍然有效，假如说你禁用了这个账户的话。</li>
<li>authorizationCodeServices ：这个属性是用来设置授权码服务的（即 AuthorizationCodeServices 的实例对象），主要用于 "authorization_code" 授权码类型模式。</li>
<li>implicitGrantService ：这个属性用于设置隐式授权模式，用来管理隐式授权模式的状态。</li>
<li>tokenGranter ：当你设置了这个东西（即 TokenGranter 接口实现），那么授权将会交由你来完全掌控，并且会忽略掉上面的这几个属性，这个属性一般是用作拓展用途的，即标准的四种授权模式已经满足不了你的需求的时候，才会考虑使用这个。</li>
</ul>
<p><strong>7.2 AuthorizationServerEndpointsConfigurer授权端点</strong></p>
<p>AuthorizationServerEndpointsConfigurer 这个配置对象有一个叫做 pathMapping() 的方法用来配置端点URL链接，它有两个参数：</p>
<ul>
<li>第一个参数： String 类型的，这个端点URL的默认链接。</li>
<li>第二个参数： String 类型的，你要进行替代的URL链接。</li>
</ul>
<p>以上的参数都将以 "/" 字符为开始的字符串，框架的默认URL链接如下列表，可以作为这个 pathMapping() 方法的第一个参数：</p>
<ul>
<li>/oauth/authorize ：授权端点。</li>
<li>/oauth/token ：令牌端点。</li>
<li>/oauth/confirm_access ：用户确认授权提交端点。</li>
<li>/oauth/error ：授权服务错误信息端点。</li>
<li>/oauth/check_token ：用于资源服务访问的令牌解析端点。</li>
<li>/oauth/token_key ：提供公有密匙的端点，如果你使用JWT令牌的话。</li>
</ul>
<p>综上AuthorizationServerEndpointsConfigurer配置如下</p>
<pre><code class="language-java">@Autowired
private AuthenticationManager authenticationManager;

@Autowired
private AuthorizationCodeServices authorizationCodeServices;

@Bean
public AuthorizationCodeServices authorizationCodeServices(){
    return new InMemoryAuthorizationCodeServices();
}

@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    endpoints
        .authenticationManager(authenticationManager)
        .authorizationCodeServices(authorizationCodeServices)
        .tokenServices(tokenServices())
        .allowedTokenEndpointRequestMethods(HttpMethod.POST);

    endpoints.pathMapping("/oauth/confirm_access","/custom/confirm_access");//自定义授权页面需要
}
</code></pre>
<p>上面需要的AuthenticationManager的定义在SpringSecurity的配置中，下面会讲到。</p>
<h3 id="8令牌端点的安全约束">8.令牌端点的安全约束</h3>
<p>AuthorizationServerSecurityConfigurer 用来配置令牌端点(Token Endpoint)的安全约束，在AuthorizationServer中配置如下。</p>
<pre><code class="language-java">@Override
public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
    security
        .tokenKeyAccess("permitAll()") //(1)
        .checkTokenAccess("permitAll()")//(2)
        .allowFormAuthenticationForClients();//(3)
}
</code></pre>
<p>（1）tokenkey这个endpoint当使用JwtToken且使用非对称加密时，资源服务用于获取公钥而开放的，这里指这个endpoint完全公开。</p>
<p>（2）checkToken这个endpoint完全公开</p>
<p>（3） 允许表单认证</p>
<h3 id="9web安全配置">9.web安全配置</h3>
<p>这里可以配置安全拦截机制、自定义登录页面、登录失败拦截器等等</p>
<p>在以下的配置中创建了<code>AuthenticationManager</code> bean，这是 7.2 中所需要的。</p>
<pre><code class="language-java">@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;

    //认证管理器
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
    //密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    //安全拦截机制
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                .authorizeRequests()
                .antMatchers("/login*","/css/*").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage("/login.html")
                .loginProcessingUrl("/login")
                .failureHandler(myAuthenticationFailureHandler);

    }
}
</code></pre>
<h2 id="三、自定义登陆页面">三、自定义登陆页面</h2>
<p>spring security默认带的登录页面不可修改，加载速度贼慢，原因是使用的css链接是国外的。所以从各方面来说自定义登录页面都是需要的。</p>
<h3 id="1创建loginhtml文件">1.创建login.html文件</h3>
<p>这个非常简单，只需要将spring security加载速度贼慢的那个页面扒下来就好。</p>
<p>项目中代码链接：<a href="https://gitee.com/kdyzm/spring-security-oauth-study/blob/master/auth-center/src/main/resources/static/login.html" target="_blank">https://gitee.com/kdyzm/spring-security-oauth-study/blob/master/auth-center/src/main/resources/static/login.html</a></p>
<h3 id="2配置拦截规则">2.配置拦截规则</h3>
<p>WebSecurityConfig下如下设置</p>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable()
        .authorizeRequests()
        .antMatchers("/login*","/css/*").permitAll()
        .anyRequest().authenticated()
        .and()
        .formLogin()
        .loginPage("/login.html")
        .loginProcessingUrl("/login")
        .failureHandler(myAuthenticationFailureHandler);
}
</code></pre>
<p><code>.antMatchers("/login*","/css/*").permitAll()</code>是必须的，否则没法登陆，会陷入重定向死循环；</p>
<pre><code class="language-java">.loginPage("/login.html")
.loginProcessingUrl("/login")
</code></pre>
<p>这两个必须一起配置，否则会login 404。</p>
<h3 id="3自定义登陆失败页面">3.自定义登陆失败页面</h3>
<p>自定义登陆页面之后登录失败的原因就不提示了，这里使用拦截器进行简单的拦截并返回给前端结果（非常丑，但能用）</p>
<pre><code class="language-java">@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
        response.setContentType("application/json;charset=utf-8");
        response.getWriter().write(JSONObject.toJSONString(exception.getMessage()));
    }
}
</code></pre>
<h2 id="四、自定义授权页面">四、自定义授权页面</h2>
<p>默认的授权页面非常丑，这里重写该页面，页面代码地址：<a href="https://gitee.com/kdyzm/spring-security-oauth-study/blob/master/auth-center/src/main/resources/templates/grant.html" target="_blank">https://gitee.com/kdyzm/spring-security-oauth-study/blob/master/auth-center/src/main/resources/templates/grant.html</a></p>
<p>然后配置OAuth访问端点替换掉原来的地址：</p>
<pre><code class="language-java">endpoints.pathMapping("/oauth/confirm_access","/custom/confirm_access");
</code></pre>
<p>同时，由于重写了页面地址，需要实现/custom/confirm_access 接口</p>
<pre><code class="language-java">@Controller
@SessionAttributes("authorizationRequest")
public class GrantController {

    /**
     * @see WhitelabelApprovalEndpoint#getAccessConfirmation(java.util.Map, javax.servlet.http.HttpServletRequest)
     * @param model
     * @param request
     * @return
     * @throws Exception
     */
    @RequestMapping("/custom/confirm_access")
    public ModelAndView getAccessConfirmation(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception {
        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get("authorizationRequest");
        ModelAndView view = new ModelAndView();
        view.setViewName("grant");
        view.addObject("clientId", authorizationRequest.getClientId());
        view.addObject("scopes",authorizationRequest.getScope());
        return view;
    }

}
</code></pre>
<h2 id="五、实现userdetailsservice接口">五、实现UserDetailsService接口</h2>
<p>完成以上配置之后基本上已经配置完了，但是还差一点，那就是实现UserDetailsService接口，不实现该接口，会出现后端死循环导致的stackoverflow问题。</p>
<p>为什么要实现该接口？</p>
<p>该接口通过userName获取用户密码信息用于校验用户密码登陆和权限信息等。</p>
<pre><code class="language-java">@Service
@Slf4j
public class MyUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        TUser tUser = userMapper.selectOne(new LambdaQueryWrapper&lt;TUser&gt;().eq(TUser::getUsername, username));
        if (Objects.isNull(tUser)) {
            throw new UsernameNotFoundException(username + "账号不存在");//return null也可以
        }
        List&lt;String&gt; allPermissions = userMapper.findAllPermissions(tUser.getId());
        String[] array = null;
        if (CollectionUtils.isEmpty(allPermissions)) {
            log.warn("{} 无任何权限", tUser.getUsername());
            array = new String[]{};
        } else {
            array = new String[allPermissions.size()];
            allPermissions.toArray(array);
        }
        return User
                .withUsername(tUser.getUsername())
                .password(tUser.getPassword())
                .authorities(array).build();
    }
}
</code></pre>
<h2 id="六、接口测试">六、接口测试</h2>
<p>在测试前，需要先执行数据库脚本并启动服务</p>
<ol>
<li>执行auth-center/docs/sql/init.sql 文件，创建数据库并创建相关的表</li>
<li>修改auth-center项目下的配置文件中的数据库连接配置</li>
</ol>
<p>然后运行 AuthCenterApplication 程序，测试几种oauth认证模式</p>
<h3 id="1-授权码认证模式">1. 授权码认证模式</h3>
<blockquote>
<p>最安全的一种模式。一般用于client是Web服务器端应用或第三方的原生App调用资源服务的时候。因为在这种模式中access_token不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大限度的减小了令牌泄漏的风险。<br>
该模式下获取token需要分两步走，第一步获取授权码，第二步获取token。</p>
</blockquote>
<ul>
<li>获取授权码</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/516671/202101/516671-20210108105029887-684415908.gif;%20charset=UTF-8" alt="授权码模式 - 获取授权码.gif" loading="lazy"></p>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/authorize</code></p>
<p><strong>请求方式</strong> <code>GET</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>client_id</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>response_type</td>
<td>固定传值<code>code</code>表示使用授权码模式进行认证</td>
</tr>
<tr>
<td>scope</td>
<td>改值必须配置的clients中的值一致</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>获取code之后重定向的地址，必须和配置的clients一致</td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=https://www.baidu.com" target="_blank">http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=https://www.baidu.com</a></p>
<p>账号密码分别输入：zhangsan/123，进入授权页面之后点击授权按钮，页面跳转之后获取到code。</p>
<ul>
<li>获取token</li>
</ul>
<p>在上一步获取到code之后，利用获取到的该code获取token。</p>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/token</code></p>
<p><strong>请求方式</strong> <code>POST</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>上一步获取到的code</td>
</tr>
<tr>
<td>grant_type</td>
<td>在授权码模式，固定使用<code>authorization_code</code></td>
</tr>
<tr>
<td>client_id</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>client_secret</td>
<td>这里的值必须和代码中配置的clients中配置的保持一致</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>获取token之后重定向的地址，该地址可以随意写</td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/token" target="_blank">http://127.0.0.1:30000/oauth/token</a></p>
<p>请求体</p>
<pre><code class="language-x-www-form-urlencoded">code:5Rmc3m
grant_type:authorization_code
client_id:c1
client_secret:secret
redirect_uri:https://www.baidu.com
</code></pre>
<h3 id="2简化模式">2.简化模式</h3>
<blockquote>
<p>该模式去掉了授权码，用户登陆之后直接获取token并显示在浏览器地址栏中，参数和请求授权码的接口基本上一模一样，唯一的区别就是<code>response_type</code>字段，授权码模式下使用的是code字段，在简化模式下使用的是token字段。一般来说，简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法接收授权码。</p>
</blockquote>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/authorize</code></p>
<p><strong>请求方式</strong> <code>GET</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>client_id</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>response_type</td>
<td>固定传值<code>token</code>表示使用简化模式进行认证</td>
</tr>
<tr>
<td>scope</td>
<td>该值必须和配置的clients中的值一致</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>获取code之后重定向的地址，必须和配置的clients一致</td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=all&amp;redirect_uri=https://www.baidu.com" target="_blank">http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=all&amp;redirect_uri=https://www.baidu.com</a></p>
<h3 id="3密码模式">3.密码模式</h3>
<blockquote>
<p>这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我<br>
们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用</p>
</blockquote>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/token</code></p>
<p><strong>请求方式</strong> <code>POST</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>client_id</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>client_secret</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>grant_type</td>
<td>在密码模式下，该值固定为<code>password</code></td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=password&amp;username=zhangsan&amp;password=123" target="_blank">http://127.0.0.1:30000/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=password&amp;username=zhangsan&amp;password=123</a></p>
<h3 id="4客户端模式">4.客户端模式</h3>
<blockquote>
<p>这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。</p>
</blockquote>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/token</code></p>
<p><strong>请求方式</strong> <code>POST</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>client_id</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>client_secret</td>
<td>改值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>grant_type</td>
<td>在密码模式下，该值固定为<code>client_credentials</code></td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials" target="_blank">http://127.0.0.1:30000/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials</a></p>
<h3 id="5refresh_token换取新token">5.refresh_token换取新token</h3>
<p><strong>接口地址</strong> <code>http://127.0.0.1:30000/oauth/token</code></p>
<p><strong>请求方式</strong> <code>POST</code></p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>client_id</td>
<td>该值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>client_secret</td>
<td>该值必须和配置在clients中的值保持一致</td>
</tr>
<tr>
<td>grant_type</td>
<td>如果想根据refresh_token换新的token，这里固定传值<code>refresh_token</code></td>
</tr>
<tr>
<td>refresh_token</td>
<td>未失效的refresh_token</td>
</tr>
</tbody>
</table>
<p><strong>请求示例</strong></p>
<p><a href="http://127.0.0.1:30000/oauth/token?grant_type=refresh_token&amp;refresh_token=09c9d11a-525a-4e5f-bac1-4f32e9025301&amp;client_id=c1&amp;client_secret=secret" target="_blank">http://127.0.0.1:30000/oauth/token?grant_type=refresh_token&amp;refresh_token=09c9d11a-525a-4e5f-bac1-4f32e9025301&amp;client_id=c1&amp;client_secret=secret</a></p>
<h2 id="七、源码地址">七、源码地址</h2>
<p>源码地址：<a href="https://gitee.com/kdyzm/spring-security-oauth-study" target="_blank">https://gitee.com/kdyzm/spring-security-oauth-study</a></p>
<p>我的博客地址：<a href="https://blog.kdyzm.cn/" target="_blank">https://blog.kdyzm.cn/</a> 欢迎大家来访啊~</p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-01-08 10:55</span>&nbsp;
<a href="https://www.cnblogs.com/kuangdaoyizhimei/">狂盗一枝梅</a>&nbsp;
阅读(<span id="post_view_count">1240</span>)&nbsp;
评论(<span id="post_comment_count">14</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14250374" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14250374);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 147792, cb_blogApp = 'kuangdaoyizhimei', cb_blogUserGuid = 'bdaaad45-60a3-e211-82de-84c4f0333004';
    var cb_entryId = 14250374, cb_entryCreatedDate = '2021-01-08 10:55', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 狂盗一枝梅
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <!-- ............自定义尾部代码开始............ -->
<div id="post-bottom-bar" class="post-bottom-bar" style="bottom: 0px;">
	<div class="bottom-bar-inner">
		<!-- 左边 -->
        <div class="bottom-bar-items social-share" style="float: left;">
            <span class="bottom-bar-item bottom-bar-facebook">
                <a id="bottom-d" href="javascript:void(0)" target="_blank">好文要赞</a>
            </span>
            <span class="bottom-bar-item bottom-bar-twitter">
                <a id="bottom-g" href="javascript:void(0)" target="_blank">关注我</a>
            </span>
            <span class="bottom-bar-item bottom-bar-qrcode">
                <a id="bottom-s" href="javascript:void(0)" target="_blank">收藏该文</a>
            </span>
        </div>
        <!-- 右边 -->
        <div class="bottom-bar-items right" style="float: right;">
            <span class="bottom-bar-item"><a id="mbottom-left" href="javascript:void(0);">←</a></span>
            <span class="bottom-bar-item"><a id="mbottom-right" href="javascript:void(0);">→</a></span>
            <span class="bottom-bar-item"><a href="#mfooter">↓</a></span>
            <span class="bottom-bar-item"><a href="#mtop">↑</a></span>
        </div>
	</div> 
</div>
<a name="mfooter"></a>

<!-- 遮罩层（用于图片点击放大），
    代码来自https://www.cnblogs.com/zhanxiaoyun/p/8259451.html-->
<div id="outerdiv" style="text-align: center;position: fixed;z-index: 1000;top: 0;left: 0;
    width: 100%;height: 100%;background-color: rgba(255,255,255,.9);display: none;">
    <img id="bigimg" style="height: auto;width: auto;border: 0; 
        margin: auto;position: absolute;top: 0;bottom: 0;left: 0;right: 0;">
</div>
<!-- ............自定义尾部代码结束............ -->


<script type="text/javascript" src="https://blog-static.cnblogs.com/files/summertime-wu/nprogress.js"></script>
<script type="text/javascript">

    //博主名称 可不改，默认取博客园提供的
    var nickName = null;
    //slogan
    var slogan = '立德立言，无闻西东';
    //icon
    var icon = "https://img2020.cnblogs.com/blog/516671/202104/516671-20210421182138882-1923189268.png";
    //默认博客背景图片
    var defaultPic="https://img2018.cnblogs.com/blog/1138447/201904/1138447-20190426121949417-1115592219.jpg";
    //icon(浏览器标题栏上的)
    var iconB="https://img2018.cnblogs.com/blog/1138447/201909/1138447-20190911161817172-1737762696.png";
    //友情链接地址
    var friendLink="https://www.cnblogs.com/kuangdaoyizhimei/p/14685396.html";
    //关于地址
    var aboutMe="https://www.cnblogs.com/kuangdaoyizhimei/p/14685428.html";
    //Github地址,假如博客username与Github username相同，不用改。
    //如 cnblogs.com/username github.com/username 这样就不用改
    var myGayhubUrl = "https://github.com/kdyzm";
</script>
<script type="text/javascript">
	/**
		用来设置初始时需要执行的js
	*/
	$(document).ready(function(){

        //获取博主名字
        if (nickName == null){
            var footerOverTestArray = $($("#footer")[0].childNodes[2]).text().trim().split(" ");
            nickName = footerOverTestArray[footerOverTestArray.length - 1];
        }

		//加载顶部进度条
	    NProgress.start();
	    NProgress.done();
	    $("#myProgressBar").hide();

	    //设置背景图片地址
	    if ($("#head_bg_img").val()!=null && $("#head_bg_img").val()!="") {
	    	$("#myheader_bg").css("background-image","url("+$("#head_bg_img").val()+")");
	    }else{
    		$("#myheader_bg").css("background-image","url("+defaultPic+")");
	    }

	    //设置标题
        if($("#cb_post_title_url").html()){
            $("#mypost_title_h").html($("#cb_post_title_url").html());
        }else{
            $("#mypost_title_h").html(nickName);
        }

	    //正文和标题淡入
	    $("#mainContent").css("opacity","1");
	    $("#mainContent").css("margin-top","0");
	    $("#mypost_title").css("opacity","1");
	    $("#mypost_title").css("top","75pt");

        /* --根据个人配置修改页面 start-- */
        //修改a链接
        var ccList = $(".c-c");
        for(var cc of ccList){
            $(cc).attr("href", $(cc).attr("href").replace("summertime-wu",currentBlogApp));
        }
        //设置Github链接
        if (myGayhubUrl != null ){$("#myGayhubUrl").attr("href",myGayhubUrl)}
        //设置友链的链接
        $("#friendLink").attr("href",friendLink);
        //设置关于的链接
        $("#aboutMe").attr("href",aboutMe);
        //设置两个iocn图标
        $("#nv-icon").attr("src",icon);
        var linkObject = document.createElement("link");
        linkObject.rel = "shortcut icon";
        linkObject.href = iconB;
        document.getElementsByTagName("head")[0].appendChild(linkObject);
        //设置底部栏按钮
        if (window.location.href == "https://www.cnblogs.com/"+currentBlogApp|| 
                window.location.href == "https://www.cnblogs.com/"+currentBlogApp+"/"||
                window.location.href == "http://www.cnblogs.com/"+currentBlogApp|| 
                window.location.href == "http://www.cnblogs.com/"+currentBlogApp+"/") {
            $("#bottom-d").html("友情链接");
            $("#bottom-d").attr("href",friendLink);
        }else{
            var url = window.location.href;
            var lastUrl = url.substring(url.lastIndexOf("/")+1);
            var mpageId = lastUrl.substring(0,lastUrl.indexOf("."));
            $("#bottom-d").click(function(){
                DiggIt(mpageId,cb_blogId,1);
                green_channel_success(this,'谢谢推荐！');
            })
        }
        /* --根据个人配置修改页面 end-- */
	})

	/**
		设置ajax请求加载完所有数据时执行的js
	*/
	setTimeout(afterAjax,1000);
	function afterAjax(){
		//假如是首页
		if (window.location.href == "https://www.cnblogs.com/"+currentBlogApp|| 
			window.location.href == "https://www.cnblogs.com/"+currentBlogApp+"/"||
			window.location.href == "http://www.cnblogs.com/"+currentBlogApp|| 
			window.location.href == "http://www.cnblogs.com/"+currentBlogApp+"/") {
			$("#mypost_title_e").html("<a href='https://cnblogs.com/"+currentBlogApp+"'>"+slogan+"</a>");
		}else{
		    var classification = null;
		    if ($("#BlogPostCategory").html()!=null && $("#BlogPostCategory").html()!= "") {
		    	classification = $("#BlogPostCategory").html();
		    	classification = classification.substring(3,classification.length);
		    }else{
		    	classification = "<a href='https://cnblogs.com/"+currentBlogApp+"'>暂未分类</a>";
		    }
		    var ftitle = "Published on "+ $("#post-date").html() + " in " +  classification
		    + " with <a href='https://cnblogs.com/"+currentBlogApp+"'>"+nickName+"</a>";
		    //设置副标题标题
		    $("#mypost_title_f").html(ftitle);
		    //设置标题分类按钮
		    $("#mypost_title_e").html(classification);
		    //设置底部导航条上一篇下一篇文章
		    var pnp = $("#post_next_prev a");
		    $("#mbottom-left").attr("href",pnp[1].href);
		    if (pnp.length>2) {
		    	$("#mbottom-right").attr("href",pnp[3].href);
		    }
		}
		$("#myheader_bg").css("filter","blur(0px)");

        //优化评论区样式
        $("#comment_form_container p:last").hide();
        $("#commentbox_opt a:last").hide();
        $("#tbCommentBody").attr('placeholder','Your comment here. Be cool. ');
	}


	/** 
		自定义的js方法
	*/
	//设置底部导航条点击关注按钮事件
	$("#bottom-g").click(function(){
		$('#green_channel_follow').click()
		return false
	})
	$("#bottom-s").click(function(){
		AddToWz(cb_entryId);
		return false;
	})


	//通过滚动条控制导航条的展现隐藏
	var oldScrollNum = 0;
	window.onscroll = function(){
		var t = document.documentElement.scrollTop || document.body.scrollTop;
		//下滑
		if (t>oldScrollNum) {
			if (t>120) {
				$("#mynavbar").css("margin-top","-70px");//顶部导航
				$("#post-bottom-bar").css("bottom","-3pc");//底部导航
			}
			if (t>300) {
				$("#right_meun").css("display","inline-block");//右侧导航
			}
		//上拉
		}else{
			//防止用a链接跳转也触发效果
			if (oldScrollNum-t<20) {
				$("#mynavbar").css("margin-top","0px");//顶部导航
				$("#post-bottom-bar").css("bottom","0");//底部导航
			}
			if (t<=300) {
				$("#right_meun").css("display","none");//右侧导航
			}
		}
		oldScrollNum = t;
	}

	//背景大图点击模糊||清晰
	$("#myheader_cover").click(function(){
		if ($("#myheader_bg").css("filter") == "blur(3px)") {
			$("#myheader_bg").css("filter","blur(0px)");
		}else{
			$("#myheader_bg").css("filter","blur(3px)");
		}
	})


    $("#outerdiv").click(function(){//再次点击淡出消失弹出层    
        $(this).fadeOut("fast");    
    }); 

 </script>

 <script type="text/javascript">  
    var setMyBlog = {
        setCopyright: function() {
            //设置版权信息，转载出处自动根据页面url生成
            var info_str = '<p>作者：<a target="_blank">@gzdaijie</a><br>'+
                '本文为作者原创，转载请注明出处：<a class="uri"></a></p><hr></hr>', 
                info = $(info_str),
                info_a = info.find("a"),
                url = window.location.href;
            $(info_a[0]).attr("href","https://github.com/gzdaijie");
            $(info_a[1]).attr("href",url).text(url);
            $("#cnblogs_post_body").prepend(info);
        },
        setCodeRow: function(){
            // 代码行号显示
            var pre = $("pre.sourceCode"); //选中需要更改的部分
            if(pre && pre.length){
                pre.each(function() {
                    var item = $(this);
                    var lang = item.attr("class").split(" ")[1]; //判断高亮的语言
                    item.html(item.html().replace(/<[^>]+>/g,"")); //将<pre>标签中的html标签去掉
                    item.removeClass().addClass("brush: " + lang +";"); //根据语言添加笔刷
                    SyntaxHighlighter.all();
                })
            }
        },
        setAtarget: function() {
            // 博客内的链接在新窗口打开
            $("#cnblogs_post_body a").each(function(){
                this.target = "_blank";
            }) 
        },
        setContent: function() {
            // 根据h2、h3标签自动生成目录
            var captions_ori = $("#cnblogs_post_body h2"),
            	captions_ori2 = $("#cnblogs_post_body h3"),
                captions = $("#cnblogs_post_body h2,#cnblogs_post_body h3").clone(),
                content = $("<ul id='right_meun'></ul>");
            $("#cnblogs_post_body").prepend(content.append(captions));
            var index = -1,index2 = -1;
            captions.replaceWith(function(){
                var self = this;
                if(self.tagName == "H2" || self.tagName == "h2"){
                    // 设置点击目录跳转
                    index += 1;
                    $('<a name="' + '_caption_' + index + '"></a>').insertBefore(captions_ori[index]); 
                    return '<li id="'+index+'li"><a href="#_caption_' + index + '">' + self.innerHTML + '</a><ul></ul></li>';
                } else {
                	// add by summertime-wu 增加h3链接跳转
                	index2 += 1;
                	$('<a name="' + '_caption' + index2 + '"></a>').insertBefore(captions_ori2[index2]); 
                	$("#"+index+"li ul").append("<li><a href='#_caption" + index2 + "' style='color:#5f5f5f;'>" +self.innerHTML+"</a></li>");
                    return ;
                }
            });
        },
        runAll: function() {
            /* 运行所有方法
             * setAtarget() 博客园内标签新窗口打开
             * setContent() 设置目录
             * setCopyright() 设置版权信息
             * setCodeRow() 代码行号显示
             */ 
            this.setAtarget(); 
            //假如为手机端不显示目录
            if(document.body.clientWidth>=1000){
                this.setContent();
            }
            // this.setCopyright();
            this.setCodeRow();
        }
    }
    setMyBlog.runAll();
</script>

<!-- 代码行号 -->
<script src="//cdn.bootcss.com/highlightjs-line-numbers.js/1.1.0/highlightjs-line-numbers.min.js"></script>
<script>hljs.initLineNumbersOnLoad();</script>
    </div>

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjuHZJo26x3LI8Ip0hvoPHEZsE2m5HMsU8fBrXdz0vR72hyfg6ztfkK6kyKc6zjGpAKw4NcVK0n3XTlqxWmq7JuOv4CWx1REC1o7fCJVhBJD2HIU4Eh9ZY7nEg0U5Egnje0" />
</body>
</html>
