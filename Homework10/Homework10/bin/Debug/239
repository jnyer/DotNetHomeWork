<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta name="description" content="Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统，专注于实时处理的异步任务队列，同时也支持任务调度。之前我们用了十几篇文章，介绍了 Kombu 和 Celery 的基础功能。从本文开始，" />
    <meta property="og:description" content="Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统，专注于实时处理的异步任务队列，同时也支持任务调度。之前我们用了十几篇文章，介绍了 Kombu 和 Celery 的基础功能。从本文开始，" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[源码分析] 并行分布式任务队列 Celery  之 Timer &amp; Heartbeat - 罗西的思考 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    <link id="MainCss" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright.min.css?v=00nt3ajQUVX0gvFynxRY-4TOqQaW32yFChuBOrvOqLk" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright-mobile.min.css?v=cSBXSFXCBG9KdnF2sdUs-Rwu75GHG2_Gs50OCy_ecGg" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/rossiXYZ/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/rossiXYZ/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/rossiXYZ/wlwmanifest.xml" />
    <script>
        var currentBlogId = 556264;
        var currentBlogApp = 'rossiXYZ';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'LessIsMoreRight';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-05-06 08:49';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=2Mic1VLeHXarpdzASbXqFMIMVLEBiWXNO5yiTHUcmhw"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;v=20200504"></script>
    
</head>
<body class="has-navbar">
    <a name="top"></a>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        

    </div>
    <div id="home">
    <div id="header">
        <div id="blogTitle">
            <div class="title"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/rossiXYZ/">罗西的思考</a>
</div>
<div class="subtitle">一手伸向技术，一手伸向生活</div>

        </div>
        <div id="navigator">
            
<ul id="navList">
    <li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
    <li id="nav_myhome">
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/rossiXYZ/">
首页</a>
</li>
    <li id="nav_newpost">

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
    <li id="nav_contact">
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%BD%97%E8%A5%BF%E7%9A%84%E6%80%9D%E8%80%83">
联系</a></li>
    <li id="nav_rss">
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/rossiXYZ/rss/">
订阅</a></li>
    <li id="nav_admin">
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>

            <div class="blogStats">
                <div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rossiXYZ/p/14696580.html">
    <span>[源码分析] 并行分布式任务队列 Celery  之 Timer &amp; Heartbeat</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统，专注于实时处理的异步任务队列，同时也支持任务调度。之前我们用了十几篇文章，介绍了 Kombu 和 Celery 的基础功能。从本文开始，我们介绍 Celery 的一些辅助功能（比如负载均衡，容错等等）。其实从某种意义上来说，这些辅助功能更加重要。本文我们介绍 Timer 和 Heart 这两个组件。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="源码分析-并行分布式任务队列-celery--之-timer--heartbeat">[源码分析] 并行分布式任务队列 Celery  之 Timer &amp; Heartbeat</h1>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#源码分析-并行分布式任务队列-celery--之-timer--heartbeat">[源码分析] 并行分布式任务队列 Celery  之 Timer &amp; Heartbeat</a><ul><li><a href="#0x00-摘要">0x00 摘要</a></li><li><a href="#"></a></li><li><a href="#0x01-blueprint">0x01 Blueprint</a></li><li><a href="#0x02-timer-step">0x02 Timer Step</a><ul><li><a href="#21-transport">2.1 Transport</a></li><li><a href="#22-thread-less-vs-thread-based">2.2 Thread-less VS Thread-based</a></li></ul></li><li><a href="#0x03-timer-in-pool">0x03 Timer in Pool</a><ul><li><a href="#31-gevent-和-eventlet">3.1 gevent 和 eventlet</a></li><li><a href="#32-basepool">3.2 BasePool</a></li></ul></li><li><a href="#0x04-kombutimer">0x04 kombu.Timer</a><ul><li><a href="#41-异步">4.1 异步</a></li><li><a href="#42-调用">4.2 调用</a><ul><li><a href="#421-添加-timer-function">4.2.1 添加 timer function</a></li><li><a href="#422-调用">4.2.2 调用</a></li></ul></li><li><a href="#43-实验">4.3 实验</a><ul><li><a href="#431-示例代码">4.3.1 示例代码</a></li><li><a href="#432-hub-的使用">4.3.2 Hub 的使用</a></li></ul></li></ul></li><li><a href="#0x05-timer2">0x05 timer2</a></li><li><a href="#0x06-heart">0x06 Heart</a><ul><li><a href="#61-heart-in-bootstep">6.1 Heart in Bootstep</a></li><li><a href="#62-heart-in-consumer">6.2 Heart in Consumer</a></li><li><a href="#63--worker-online">6.3  worker-online</a></li><li><a href="#64-worker-offline">6.4 worker-offline</a></li><li><a href="#65-发送心跳">6.5 发送心跳</a></li></ul></li><li><a href="#0xee-个人信息">0xEE 个人信息</a></li><li><a href="#0xff-参考">0xFF 参考</a></li></ul></li></ul></div><p></p>
<h2 id="0x00-摘要">0x00 摘要</h2>
<p>Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统，专注于实时处理的异步任务队列，同时也支持任务调度。</p>
<p>之前我们用了十几篇文章，介绍了 Kombu 和 Celery 的基础功能。从本文开始，我们介绍 Celery 的一些辅助功能（比如负载均衡，容错等等）。其实从某种意义上来说，这些辅助功能更加重要。</p>
<p>本文我们介绍 Timer 和 Heart 这两个组件。大家可以看看底层设计是如何影响上层实现的。</p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14455431.html" target="_blank">源码分析] 消息队列 Kombu 之 mailbox</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14455294.html" target="_blank">源码分析] 消息队列 Kombu 之 Hub</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14455093.html" target="_blank">源码分析] 消息队列 Kombu 之 Consumer</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14455186.html" target="_blank">源码分析] 消息队列 Kombu 之 Producer</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14454934.html" target="_blank">源码分析] 消息队列 Kombu 之 启动过程</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14454761.html" target="_blank">源码解析] 消息队列 Kombu 之 基本架构</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14562308.html" target="_blank">源码解析] 并行分布式框架 Celery 之架构 (1)</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14562310.html" target="_blank">源码解析] 并行分布式框架 Celery 之架构 (2)</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14563763.html" target="_blank">源码解析] 并行分布式框架 Celery 之 worker 启动 (1)</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14563777.html" target="_blank">源码解析] 并行分布式框架 Celery 之 worker 启动 (2)</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14612853.html" target="_blank">源码解析] 分布式任务队列 Celery 之启动 Consumer</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14613110.html" target="_blank">源码解析] 并行分布式任务队列 Celery 之 Task是什么</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14672090.html" target="_blank">从源码学设计]celery 之 发送Task &amp; AMQP </a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14639556.html" target="_blank">源码解析] 并行分布式任务队列 Celery 之 消费动态流程</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14664004.html" target="_blank">源码解析] 并行分布式任务队列 Celery 之 多进程模型</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14672168.html" target="_blank">源码分析] 分布式任务队列 Celery 多线程模型 之 子进程</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/14696573.html" target="_blank">源码分析]并行分布式任务队列 Celery 之 子进程处理消息</a></p>
<h2 id=""></h2>
<h2 id="0x01-blueprint">0x01 Blueprint</h2>
<p>Celery  的 Worker初始化过程中，其内部各个子模块的执行顺序是由一个BluePrint类定义，并且根据各个模块之间的依赖进行排序（实际上把这种依赖关系组织成了一个 DAG）执行。</p>
<p>Celery worker 的 Blueprint 如下，我们可以看到 Timer，Hub 是 Celery Worker 的两个基本组件，提到 hub 是因为后面讲解需要用到。</p>
<pre><code class="language-python">class Blueprint(bootsteps.Blueprint):
    """Worker bootstep blueprint."""

    name = 'Worker'
    default_steps = {
        'celery.worker.components:Hub', # 这里是 Hub
        'celery.worker.components:Pool',
        'celery.worker.components:Beat',
        'celery.worker.components:Timer', # 这里是 Timer
        'celery.worker.components:StateDB',
        'celery.worker.components:Consumer',
        'celery.worker.autoscale:WorkerComponent',
    }
</code></pre>
<h2 id="0x02-timer-step">0x02 Timer Step</h2>
<p>我们首先来到 Timer Step。</p>
<p>从 Timer 组件 的定义中可以看到，<u>Timer 组件 会根据当前worker是否使用事件循环机制来决定创建什么类型的timer</u>。</p>
<ul>
<li>如果使用 eventloop，则使用<code>kombu.asynchronous.timer.Timer as _Timer</code>，这里<u>具体等待动作由用户自己完成</u>。</li>
<li>否则使用 Pool 内部的Timer类（就是 <code>timer_cls='celery.utils.timer2.Timer'</code>），timer2 自己做了一个<u>线程来做定时等待</u>；</li>
</ul>
<p>定义如下：</p>
<pre><code class="language-python">from kombu.asynchronous.timer import Timer as _Timer

class Timer(bootsteps.Step):
    """Timer bootstep."""

    def create(self, w):
        if w.use_eventloop:                        # 检查传入的Worker是否使用了use_eventloop
            # does not use dedicated timer thread.
            w.timer = _Timer(max_interval=10.0)    # 直接使用kombu的timer做定时器
        else:
            if not w.timer_cls:                     # 如果配置文件中没有配置timer_clas
                # Default Timer is set by the pool, as for example, the
                # eventlet pool needs a custom timer implementation.
                w.timer_cls = w.pool_cls.Timer      # 使用缓冲池中的Timer
            w.timer = self.instantiate(w.timer_cls,
                                       max_interval=w.timer_precision,
                                       on_error=self.on_timer_error,
                                       on_tick=self.on_timer_tick)  # 导入对应的类并实例化
</code></pre>
<p>起初看代码时候很奇怪，为什么要再单独定义一个 timer2？</p>
<p>原因推断是（因为对 Celery 的版本发展历史不清楚，所以此处不甚确定，希望有同学可以指正）：<u>依据 底层 Transport 的设计来对 Timer 做具体实现调整</u>。</p>
<h3 id="21-transport">2.1 Transport</h3>
<p>大家知道，Celery 是依赖于 Kombu，而在 Kombu 体系中，用 transport 对所有的 broker 进行了抽象，为不同的 broker 提供了一致的解决方案。通过Kombu，开发者可以根据实际需求灵活的选择或更换broker。</p>
<p>我们再回顾下具体 Kombu 的概念：</p>
<ul>
<li>Connection 是 AMQP 对 连接的封装；</li>
<li>Channel 是 AMQP 对 MQ 操作的封装；</li>
</ul>
<p>那么两者的关系就是对 MQ 的操作（Channel）必然离不开连接（Connection），但是 Kombu 并不直接让 Channel 使用 Connection 来发送  / 接受请求，而是引入了一个新的抽象 Transport。Transport 负责具体的 MQ 的操作，也就是说 Channel 的操作都会落到 Transport 上执行；</p>
<p>Transport 代表真实的 MQ 连接，也是真正连接到 MQ（ redis / rabbitmq ）的实例。就是存储和发送消息的实体，用来区分底层消息队列是用 amqp、Redis 还是其它实现的。</p>
<p>具体 Kombu 逻辑如下图，Transport 在左下角处 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20210227090834784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzM2NDY4Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="22-thread-less-vs-thread-based">2.2 Thread-less VS Thread-based</h3>
<p>对于 Transport，某些 rate-limit implementation（比如 RabbitMQ / Redis ） 为了减少开销，采用了event-loop（底层使用了 Epoll），是 <u>thread-less and lock-free</u>。</p>
<p>而其他旧类型的 Transport 就是 <u>Thread based</u>，比如 Mongo。因此，</p>
<ul>
<li>
<p>对于 Thread-less Transport</p>
<ul>
<li>
<p>Kombu 就采用了 <code>kombu.asynchronous.timer.Timer as _Timer</code>，具体等待操作是在 event-loop 中实现，就是 调用者 自己会做等待。</p>
</li>
<li>
<p>具体比如在 Redis Transport 之中，就有 register_with_event_loop 函数用来在 loop（就是 event-loop）中注册自己，具体如下：</p>
</li>
<li>
<pre><code class="language-python">def register_with_event_loop(self, connection, loop):
    cycle = self.cycle
    cycle.on_poll_init(loop.poller)
    cycle_poll_start = cycle.on_poll_start
    add_reader = loop.add_reader
    on_readable = self.on_readable

    def on_poll_start():
        cycle_poll_start()
        [add_reader(fd, on_readable, fd) for fd in cycle.fds]
    loop.on_tick.add(on_poll_start)
    loop.call_repeatedly(10, cycle.maybe_restore_messages)
    loop.call_repeatedly(
        health_check_interval,
        cycle.maybe_check_subclient_health
    )
</code></pre>
</li>
</ul>
</li>
<li>
<p>对于 thread-based Transport，</p>
<ul>
<li>则采用了 celery.utils.timer2.Timer，timer2 自己继承了线程类，使用自己这个<u>线程来做定时等待</u>；</li>
<li>比如在 Mongodb transport 之中，就没有任何关于 event loop 的操作。</li>
</ul>
</li>
</ul>
<p>即，<u>选用 timer 的哪种实现，看是否需要等待来决定，就是谁来完成 “等待” 这个动作</u>。</p>
<p>翻了翻 <strong>Celery 2.4.7</strong> 的代码，发现在这个版本，确实只有 Thread-based timer，其代码涵盖了 目前的 timer 2 和 <code>kombu.asynchronous.timer.Timer</code> 大部分功能。应该是从 3.0.2 之后，把部分代码分离到了 <code>kombu.asynchronous.timer.Timer</code> ，实现了 Thread-less 和 Thread-based 两个不同的实现。</p>
<p>具体可以参见下面源码中的注释：</p>
<pre><code class="language-python">- RabbitMQ/Redis: thread-less and lock-free rate-limit implementation.

    This means that rate limits pose minimal overhead when used with
    RabbitMQ/Redis or future transports using the event-loop,
    and that the rate-limit implementation is now thread-less and lock-free.

    The thread-based transports will still use the old implementation for
    now, but the plan is to use the timer also for other
    broker transports in Celery 3.1.
</code></pre>
<h2 id="0x03-timer-in-pool">0x03 Timer in Pool</h2>
<p>注意，<u>上面的是 Timer Step，是一个启动的阶段，其目的是生成 Timer 组件 给 其他组件使用，并不是 Timer 功能类</u>。</p>
<p>我们其次来看看 <u>Timer 功能类 在 线程池 Pool 中的使用</u>，就对应了前面 Blueprint step 之中的两种不同 cases。</p>
<p>分别也对应了两种应用场景（或者说是线程池实现）：</p>
<ul>
<li>gevent 和 eventlet 使用 <code>kombu.asynchronous.timer.Timer</code>。</li>
<li>BasePool（以及其他类型线程池）使用了 <code>timer2.Timer。</code></li>
</ul>
<p>初步来分析，gevent 和 eventlet 都是用协程来模拟线程，所以本身具有Event loop，因此使用  <code>kombu.asynchronous.timer.Timer</code> 也算顺理成章。</p>
<h3 id="31-gevent-和-eventlet">3.1 gevent 和 eventlet</h3>
<p>对于 gevent，eventlet 这种情况，使用了 class Timer(_timer.Timer) 作为 Timer 功能类。</p>
<p>从代码中可以看到，class Timer 扩展了 <code>kombu.asynchronous.timer.Timer</code>。</p>
<pre><code class="language-python">from kombu.asynchronous import timer as _timer

class Timer(_timer.Timer):

    def __init__(self, *args, **kwargs):
        from gevent import Greenlet, GreenletExit

        class _Greenlet(Greenlet):
            cancel = Greenlet.kill

        self._Greenlet = _Greenlet
        self._GreenletExit = GreenletExit
        super().__init__(*args, **kwargs)
        self._queue = set()

    def _enter(self, eta, priority, entry, **kwargs):
        secs = max(eta - monotonic(), 0)
        g = self._Greenlet.spawn_later(secs, entry)
        self._queue.add(g)
        g.link(self._entry_exit)
        g.entry = entry
        g.eta = eta
        g.priority = priority
        g.canceled = False
        return g

    def _entry_exit(self, g):
        try:
            g.kill()
        finally:
            self._queue.discard(g)

    def clear(self):
        queue = self._queue
        while queue:
            try:
                queue.pop().kill()
            except KeyError:
                pass

    @property
    def queue(self):
        return self._queue
</code></pre>
<h3 id="32-basepool">3.2 BasePool</h3>
<p>而 BasePool 采用了 <code>timer2 . Timer</code> 作为 Timer 功能类。</p>
<pre><code class="language-python">from celery.utils import timer2

class BasePool:
    """Task pool."""

    Timer = timer2.Timer
</code></pre>
<p>下面我们具体看看 Timer 功能类 如何实现。</p>
<h2 id="0x04-kombutimer">0x04 kombu.Timer</h2>
<h3 id="41-异步">4.1 异步</h3>
<p><code>kombu.asynchronous.timer.Timer</code> 实现了异步Timer。</p>
<p>由其注释可以，kombu.asynchronous.timer.Timer 在调用者每次得到下一次entry时，会给出tuple of <code>(wait_seconds, entry)</code>，<u>调用者应该进行等待相应时间</u>。</p>
<p>即，<u>kombu.Timer是调用者等待，普通timer是timer自己启动线程等待</u>。</p>
<pre><code class="language-python">"""Iterate over schedule.
This iterator yields a tuple of ``(wait_seconds, entry)``,
where if entry is :const:`None` the caller should wait
for ``wait_seconds`` until it polls the schedule again.
"""
</code></pre>
<p>定义如下：</p>
<pre><code class="language-python">class Timer:
    """Async timer implementation."""

    Entry = Entry

    on_error = None

    def __init__(self, max_interval=None, on_error=None, **kwargs):
        self.max_interval = float(max_interval or DEFAULT_MAX_INTERVAL)
        self.on_error = on_error or self.on_error
        self._queue = []
</code></pre>
<h3 id="42-调用">4.2 调用</h3>
<h4 id="421-添加-timer-function">4.2.1 添加 timer function</h4>
<p>用户通过 call_repeatedly 来添加 timer function。</p>
<pre><code class="language-python">def call_repeatedly(self, secs, fun, args=(), kwargs=None, priority=0):
    kwargs = {} if not kwargs else kwargs
    tref = self.Entry(fun, args, kwargs)

    @wraps(fun)
    def _reschedules(*args, **kwargs):
        last, now = tref._last_run, monotonic()
        lsince = (now - tref._last_run) if last else secs
        try:
            if lsince and lsince &gt;= secs:
                tref._last_run = now
                return fun(*args, **kwargs) # 调用用户方法
        finally:
            if not tref.canceled:
                last = tref._last_run
                next = secs - (now - last) if last else secs
                self.enter_after(next, tref, priority)

    tref.fun = _reschedules
    tref._last_run = None
    return self.enter_after(secs, tref, priority)
</code></pre>
<h4 id="422-调用">4.2.2 调用</h4>
<p>Timer通过apply_entry进行调用。</p>
<pre><code class="language-python">def apply_entry(self, entry):
    try:
        entry()
    except Exception as exc:
        if not self.handle_error(exc):
            logger.error('Error in timer: %r', exc, exc_info=True)
</code></pre>
<p>在获取下一次entry时，会返回等待时间。</p>
<pre><code class="language-python">def __iter__(self, min=min, nowfun=monotonic,
             pop=heapq.heappop, push=heapq.heappush):
    """Iterate over schedule.

    This iterator yields a tuple of ``(wait_seconds, entry)``,
    where if entry is :const:`None` the caller should wait
    for ``wait_seconds`` until it polls the schedule again.
    """
    max_interval = self.max_interval
    queue = self._queue

    while 1:
        if queue:
            eventA = queue[0]
            now, eta = nowfun(), eventA[0]

            if now &lt; eta:
                yield min(eta - now, max_interval), None
            else:
                eventB = pop(queue)

                if eventB is eventA:
                    entry = eventA[2]
                    if not entry.canceled:
                        yield None, entry
                    continue
                else:
                    push(queue, eventB)
        else:
            yield None, None
</code></pre>
<h3 id="43-实验">4.3 实验</h3>
<p>我们做实验看看 timer 功能类 的 使用。</p>
<h4 id="431-示例代码">4.3.1 示例代码</h4>
<p>下面代码来自https://github.com/liuliqiang/blog_codes/tree/master/python/celery/kombu，特此感谢。</p>
<pre><code class="language-python">def main(arguments):
    hub = Hub()
    exchange = Exchange('asynt')
    queue = Queue('asynt', exchange, 'asynt')

    def send_message(conn):
        producer = Producer(conn)
        producer.publish('hello world', exchange=exchange, routing_key='asynt')
        print('message sent')

    def on_message(message):
        print('received: {0!r}'.format(message.body))
        message.ack()
        # hub.stop()  # &lt;-- exit after one message

    conn = Connection('redis://localhost:6379')
    conn.register_with_event_loop(hub)

    def p_message():
        print('redis://localhost:6379')

    with Consumer(conn, [queue], on_message=on_message):
        send_message(conn)
        hub.timer.call_repeatedly(
            3, p_message
        )
        hub.run_forever()


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
</code></pre>
<p>这里，<u>Hub 就是 timer 的客户</u>。</p>
<p>得到Stack如下，可以看到 hub 使用 timer 做了消息循环，于是我们需要看看 hub：</p>
<pre><code class="language-python">p_message
_reschedules, timer.py:127
__call__, timer.py:65
fire_timers, hub.py:142
create_loop, hub.py:300
run_once, hub.py:193
run_forever, hub.py:185
main, testUb.py:46
&lt;module&gt;, testUb.py:50
</code></pre>
<p>启动时候的逻辑如下，hub 通过 <u>hub.timer.call_repeatedly</u> 设置了需要调用的用户函数 fun，在 Timer 内部，fun 被包装设置为 _reschedules。</p>
<pre><code class="language-java">    Hub
     +
     |                                         +----------------------------------+
     |                                         |  kombu.asynchronous.timer.Timer  |
     |                                         |                                  |
     |                call_repeatedly(fun)     |                                  |
     |                                         |                                  |
     +----------------------------------------------&gt;  _reschedules [@wraps(fun)] |
     |                                         |                                  |
     |                                         |                                  |
     |                                         |                                  |
     |                                         +----------------------------------+
     |
     |
     v

</code></pre>
<h4 id="432-hub-的使用">4.3.2 Hub 的使用</h4>
<p>以下代码是Hub类，在这里，Hub 就是 timer 的用户。</p>
<p>可以看到，hub 建立了message_loop。在 loop 中，hub 会：</p>
<ul>
<li>使用 fire_timers 进行 timer 处理，会设置下一次 timer。</li>
<li>得到 poll_timeout 后，会进行处理或者 <strong>sleep</strong>。</li>
</ul>
<p>下面是简化版代码。</p>
<pre><code class="language-python">def create_loop():

    while 1:

        poll_timeout = fire_timers(propagate=propagate) if scheduled else 1

        if readers or writers:

            events = poll(poll_timeout)

            for fd, event in events or ():

                if event &amp; READ:
                    try:
                        cb, cbargs = readers[fd]
                    try:
                        cb(*cbargs)
                    except Empty:
                        pass

        else:
            # no sockets yet, startup is probably not done.
            sleep(min(poll_timeout, 0.1))
        yield
</code></pre>
<p>我们再看看 fire_timers，这就是调用用户方法。</p>
<pre><code class="language-python">def fire_timers(self, min_delay=1, max_delay=10, max_timers=10,
                propagate=()):
    timer = self.timer
    delay = None
    
    if timer and timer._queue:
        for i in range(max_timers):
            delay, entry = next(self.scheduler)
            if entry is None:
                break

            entry()# 调用用户方法
            
    return min(delay or min_delay, max_delay)
</code></pre>
<p>使用Entry调用用户方法</p>
<pre><code class="language-python">class Entry:
    """Schedule Entry."""

    def __call__(self):
        return self.fun(*self.args, **self.kwargs)# 调用用户方法
</code></pre>
<p>具体逻辑如下：</p>
<pre><code class="language-java">+--------------------------+
|                          |
|              Hub         |
|               +          |
|               |          |                        +----------------------------------+
|               |          |                        |  kombu.asynchronous.timer.Timer  |
|               |          |                        |                                  |
|               |          |  call_repeatedly(fun)  |                                  |
|               |          |                        |                                  |
|               +----------------------------------------&gt;  _reschedules [@wraps(fun)] |
|               |          |                        |                                  |
|               |          |                        |                                  |
|               |          |                        |                                  |
|               |          |                        +----------------------------------+
|            create_loop   |
|               +          |                                   ^
|               |          |                                   |
|               |          |                                   |
|               v          |                                   |
|                          |                                   |
|   +---&gt;  message_loop    |                                   |
|   |           +          |                                   |
|   |           |          |                                   |
|   |           v          |        iter(self.timer)           |
|   |       fire_timers +--------------------------------------+
|   |           +          |
|   |           |          |
|   |           v          |
|   |         poll         |
|   |           +          |
|   |           |          |
|   |           v          |
|   |         sleep        |
|   |           +          |
|   |           |          |
|   +-----------+          |
+--------------------------+
</code></pre>
<h2 id="0x05-timer2">0x05 timer2</h2>
<p>在<code>celery/utils/timer2.py</code>中定义了<code>Timer</code>类实例，可以看出其继承了threading.Thread，但是居然也用<code>kombu.asynchronous.timer</code>。</p>
<p>在源码注释中有：<code>This is only used for transports not supporting AsyncIO</code>。</p>
<p>其实，<u>就是 timer2 自己做了一个线程来做定时sleep等待，然后调用用户方法而已</u>。</p>
<pre><code class="language-python">from kombu.asynchronous.timer import Entry
from kombu.asynchronous.timer import Timer as Schedule
from kombu.asynchronous.timer import logger, to_timestamp

class Timer(threading.Thread): # 扩展了 线程
    """Timer thread.

    Note:
        This is only used for transports not supporting AsyncIO.
    """

    Entry = Entry
    Schedule = Schedule

    running = False
    on_tick = None

    _timer_count = count(1)
</code></pre>
<p>在run方法中，会定期sleep。</p>
<pre><code class="language-python">def run(self):
    try:
        self.running = True
        self.scheduler = iter(self.schedule)

        while not self._is_shutdown.isSet():
            delay = self._next_entry()
            if delay:
                if self.on_tick:
                    self.on_tick(delay)
                if sleep is None:  # pragma: no cover
                    break
                sleep(delay)
        try:
            self._is_stopped.set()
        except TypeError:  # pragma: no cover
            # we lost the race at interpreter shutdown,
            # so gc collected built-in modules.
            pass
    except Exception as exc:
        sys.stderr.flush()
        os._exit(1)
</code></pre>
<p>在_next_entry方法中，调用用户方法，这是通过<code>kombu.asynchronous.timer</code>完成的。</p>
<pre><code class="language-python">def _next_entry(self):
    with self.not_empty:
        delay, entry = next(self.scheduler)
        if entry is None:
            if delay is None:
                self.not_empty.wait(1.0)
            return delay
    return self.schedule.apply_entry(entry)
__next__ = next = _next_entry  # for 2to3
</code></pre>
<h2 id="0x06-heart">0x06 Heart</h2>
<p>Timer 类主要是做一些定时调度方面的工作。</p>
<p>Heart 组件 就是使用 Timer组件 进行定期调度，发送心跳 Event，告诉其他 Worker 这个 Worker 还活着。</p>
<p>同时，当本worker 启动，停止时候，也发送 worker-online，worker-offline 这两种消息。</p>
<h3 id="61-heart-in-bootstep">6.1 Heart in Bootstep</h3>
<p>位置在：celery/worker/consumer/heart.py。</p>
<p>其作用就是启动 heart 功能类。</p>
<pre><code class="language-python">class Heart(bootsteps.StartStopStep):
    """Bootstep sending event heartbeats.

    This service sends a ``worker-heartbeat`` message every n seconds.

    Note:
        Not to be confused with AMQP protocol level heartbeats.
    """

    requires = (Events,)

    def __init__(self, c,
                 without_heartbeat=False, heartbeat_interval=None, **kwargs):
        self.enabled = not without_heartbeat
        self.heartbeat_interval = heartbeat_interval
        c.heart = None
        super().__init__(c, **kwargs)

    def start(self, c):
        c.heart = heartbeat.Heart(
            c.timer, c.event_dispatcher, self.heartbeat_interval,
        )
        c.heart.start()

    def stop(self, c):
        c.heart = c.heart and c.heart.stop()
    shutdown = stop
</code></pre>
<h3 id="62-heart-in-consumer">6.2 Heart in Consumer</h3>
<p>位置在：celery/worker/heartbeat.py。可以看到就是<u>从启动之后，使用 call_repeatedly 定期发送心跳</u>。</p>
<pre><code class="language-python">class Heart:
    """Timer sending heartbeats at regular intervals.

    Arguments:
        timer (kombu.asynchronous.timer.Timer): Timer to use.
        eventer (celery.events.EventDispatcher): Event dispatcher
            to use.
        interval (float): Time in seconds between sending
            heartbeats.  Default is 2 seconds.
    """

    def __init__(self, timer, eventer, interval=None):
        self.timer = timer
        self.eventer = eventer

    def _send(self, event, retry=True):
        return self.eventer.send(event, freq=self.interval, ...)

    def start(self):
        if self.eventer.enabled:
            self.tref = self.timer.call_repeatedly(
                self.interval, self._send, ('worker-heartbeat',),
            )
</code></pre>
<p>此时变量为：</p>
<pre><code class="language-java">self = {Heart} &lt;celery.worker.heartbeat.Heart object at 0x000001D377636408&gt;
 eventer = {EventDispatcher} &lt;celery.events.dispatcher.EventDispatcher object at 0x000001D37765B308&gt;
 interval = {float} 2.0
 timer = {Timer: 0} &lt;Timer(Timer-1, stopped daemon)&gt;
 tref = {NoneType} None
  _send_sent_signal = {NoneType} None
</code></pre>
<h3 id="63--worker-online">6.3  worker-online</h3>
<p>当启动时候，发送 worker-online 消息。</p>
<pre><code class="language-python">    def start(self):
        if self.eventer.enabled:
            self._send('worker-online')
            self.tref = self.timer.call_repeatedly(
                self.interval, self._send, ('worker-heartbeat',),
            )
</code></pre>
<h3 id="64-worker-offline">6.4 worker-offline</h3>
<p>当停止时候，发送 worker-offline 消息。</p>
<pre><code class="language-python">    def stop(self):
        if self.tref is not None:
            self.timer.cancel(self.tref)
            self.tref = None
        if self.eventer.enabled:
            self._send('worker-offline', retry=False)
</code></pre>
<h3 id="65-发送心跳">6.5 发送心跳</h3>
<p>Heart组件会调用 eventer 来群发心跳：</p>
<ul>
<li>eventer 是 celery.events.dispatcher.EventDispatcher;</li>
<li>心跳是 'worker-heartbeat' 这个 Event；</li>
</ul>
<p>所以我们下文就要分析 celery.events.dispatcher.EventDispatcher。</p>
<pre><code class="language-python">    def _send(self, event, retry=True):
        if self._send_sent_signal is not None:
            self._send_sent_signal(sender=self)
        return self.eventer.send(event, freq=self.interval,
                                 active=len(active_requests),
                                 processed=all_total_count[0],
                                 loadavg=load_average(),
                                 retry=retry,
                                 **SOFTWARE_INFO)
</code></pre>
<h2 id="0xee-个人信息">0xEE 个人信息</h2>
<p>★★★★★★关于生活和技术的思考★★★★★★</p>
<p>微信公众账号：<u><strong>罗西的思考</strong></u></p>
<p>如果您想及时得到个人撰写文章的消息推送，或者想看看个人推荐的技术资料，敬请关注。</p>
<p><img src="https://files.cnblogs.com/files/rossiXYZ/RossiXYZ_qrcode.bmp" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="0xff-参考">0xFF 参考</h2>
<p><a href="https://liqiang.io/post/state-and-result-implement-in-celery?lang=ZH_CN" target="_blank">8: State 和 Result</a></p>
<p><a href="https://liqiang.io/post/celery-source-analysis-event-implemention?lang=ZH_CN" target="_blank">6: Events 的实现</a></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-05-06 20:49</span>&nbsp;
<a href="https://www.cnblogs.com/rossiXYZ/">罗西的思考</a>&nbsp;
阅读(<span id="post_view_count">102</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14696580" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14696580);return false;">收藏</a></div>
        </div>
        <script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 556264, cb_blogApp = 'rossiXYZ', cb_blogUserGuid = '3d1961d5-3b13-4975-9d25-08d753a9a8fd';
    var cb_entryId = 14696580, cb_entryCreatedDate = '2021-05-06 20:49', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
        <a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

    </div>
</div>
            </div>
        </div>

        <div id="sideBar">
            <div id="sideBarMain">
                <div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
                <div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                <script>loadBlogDefaultCalendar();</script>
                <div id="leftcontentcontainer">
                    <!-- begin:SingleColumn -->
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                    <!-- end:  SingleColumn -->
                </div>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <div class="clear"></div>
    <div id="footer">
        <!--done-->
Copyright &copy; 2021 罗西的思考
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>

    </div>
</div>

    

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjuS67WPGQYP98dmwlxaYOKbOcJnC2VWFUwvJmkiqRxzcuqaTzs0EYBoatvsGYdDmpwc5wuMDiaYMUSwuqbTrbHTnEIMPgxteAmLfFt8jk1JT85Q_WdqqiKa_jRrAaT-AHs" />
</body>
</html>
